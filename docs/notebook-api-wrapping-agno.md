# How Notebook APIs Wrap Agno APIs

## Overview

The application has **two layers** of APIs running on the same FastAPI server:

1. **Agno built-in APIs** — Auto-generated by `AgentOS`, mounted at the root (`/teams`, `/agents`, `/sessions`, `/health`)
2. **Custom Notebook APIs** — Hand-written endpoints mounted under `/api` that wrap and extend the Agno APIs

The Notebook APIs act as a **domain-specific facade** over the generic Agno team execution engine, adding notebook context, session linking, and CRUD operations that Agno knows nothing about.

---

## Architecture Diagram

```
Frontend (Next.js)
│
├── Generic Agno UI ──────────────────┐
│   (agent/team selector, sessions)   │
│                                     ▼
│                          ┌──────────────────────────┐
│                          │   Agno Built-in Routes    │
│                          │  (auto-generated by       │
│                          │   AgentOS)                │
│                          ├──────────────────────────┤
│                          │ GET  /health              │
│                          │ GET  /teams               │
│                          │ GET  /agents              │
│                          │ POST /teams/{id}/runs     │ ◄── raw team execution
│                          │ GET  /sessions            │
│                          │ GET  /sessions/{id}/runs  │
│                          │ DEL  /sessions/{id}       │
│                          └──────────────────────────┘
│
├── Notebook UI ──────────────────────┐
│   (notebook pages, notebook chat)   │
│                                     ▼
│                          ┌──────────────────────────────┐
│                          │   Custom Notebook Routes      │
│                          │  (hand-written, /api prefix)  │
│                          ├──────────────────────────────┤
│                          │ GET    /api/notebooks         │  pure CRUD
│                          │ POST   /api/notebooks         │  pure CRUD
│                          │ GET    /api/notebooks/{id}    │  pure CRUD
│                          │ PUT    /api/notebooks/{id}    │  pure CRUD
│                          │ DELETE /api/notebooks/{id}    │  pure CRUD
│                          │ GET    /api/notebooks/{id}/   │
│                          │        sessions               │  custom query
│                          │ POST   /api/notebooks/{id}/   │
│                          │        run                    │  ◄── WRAPS Agno
│                          └──────────────────────────────┘
```

---

## How the Server Assembles Both Layers

In `app/main.py`:

```python
# 1. AgentOS creates the FastAPI app with built-in routes
agent_os = AgentOS(
    name="NotebookLM",
    id="notebooklm-os",
    db=get_postgres_db(),
    teams=[notebooklm_team],      # registers /teams, /teams/{id}/runs, etc.
)

# 2. Inject AgentOS reference into notebook API module
set_agent_os(agent_os)

# 3. Get the FastAPI app (already has Agno routes)
app = agent_os.get_app()

# 4. Mount custom notebook routes under /api
app.include_router(notebooks_router, prefix="/api")
```

The result is a single FastAPI app serving both Agno's auto-generated routes and custom notebook routes.

---

## Endpoint-by-Endpoint Breakdown

### Pure CRUD Endpoints (no Agno involvement)

These endpoints only touch the custom `notebooks` and `notebook_sessions` tables. Agno is not involved at all.

| Endpoint | What it does | Agno involved? |
|---|---|---|
| `GET /api/notebooks` | List all notebooks | No |
| `POST /api/notebooks` | Create a notebook | No |
| `GET /api/notebooks/{id}` | Get one notebook | No |
| `PUT /api/notebooks/{id}` | Update a notebook | No |
| `DELETE /api/notebooks/{id}` | Delete a notebook | No |
| `GET /api/notebooks/{id}/sessions` | List sessions for a notebook | No (queries `notebook_sessions` table) |

### The Wrapper Endpoint: `POST /api/notebooks/{id}/run`

This is the only endpoint that **wraps Agno**. Here is exactly what it does, step by step:

```
User sends: POST /api/notebooks/4/run
  body: { message: "recommend books", session_id: "73cc...", stream: true }

Step 1: Fetch notebook from DB
  ─── SELECT * FROM notebooks WHERE id = 4
  ─── Gets: title="Books", description="questions about books",
             instructions="search in internet and recommend books"

Step 2: Build context prefix (NOTEBOOK-SPECIFIC LOGIC)
  ─── "[Notebook: Books]"
  ─── "[Description: questions about books in the internet]"
  ─── "[Instructions: search in internet and recommend books]"
  ─── Prepends this to the user message

Step 3: Get team from AgentOS
  ─── get_team_by_id("notebooklm", agent_os.teams, agent_os.db, create_fresh=True)
  ─── Returns a fresh instance of the NotebookLM Team

Step 4: Handle session_id
  ─── If no session_id provided → generate a new UUID
  ─── Save notebook↔session link in notebook_sessions table

Step 5: Call Agno's team execution (THE ACTUAL WRAP)
  ─── team_response_streamer(team, full_message, session_id=..., user_id=...)
  ─── Returns SSE stream → forwarded directly to frontend
```

### What the wrapper adds vs raw Agno

| Aspect | Raw Agno (`POST /teams/{id}/runs`) | Notebook wrapper (`POST /api/notebooks/{id}/run`) |
|---|---|---|
| Message | Sent as-is | Prefixed with notebook title, description, and instructions |
| Session tracking | Agno manages `agno_sessions` only | Also links session to notebook in `notebook_sessions` table |
| Session creation | Client must provide or Agno generates | Auto-generates UUID if missing |
| Team resolution | By team ID in URL path | Hardcoded to `"notebooklm"` team |
| Notebook context | None — Agno has no concept of notebooks | Injected as `[Notebook: ...]\n[Description: ...]\n[Instructions: ...]` |
| Streaming | `team_response_streamer` | Same `team_response_streamer` (identical SSE format) |

---

## Frontend Routing Logic

The frontend decides which endpoint to call based on the current context. From `useAIStreamHandler.tsx`:

```typescript
// Use notebook-specific run endpoint when inside a notebook
if (currentNotebook) {
  RunUrl = APIRoutes.NotebookRun(endpointUrl, currentNotebook.id)
  // → POST /api/notebooks/{id}/run
} else if (mode === 'team' && teamId) {
  RunUrl = APIRoutes.TeamRun(endpointUrl, teamId)
  // → POST /teams/{teamId}/runs  (raw Agno)
} else if (mode === 'agent' && agentId) {
  RunUrl = APIRoutes.AgentRun(endpointUrl)
  // → POST /agents/{agentId}/runs  (raw Agno)
}
```

Both the notebook endpoint and the raw Agno endpoint return the **same SSE stream format** (`RunEvent` chunks), so the frontend stream handler works identically for both. The only difference is which URL is called.

---

## Frontend API Modules

| Module | Purpose | Talks to |
|---|---|---|
| `src/api/notebooks.ts` | CRUD operations for notebooks + session listing | Custom `/api/notebooks/*` endpoints |
| `src/api/os.ts` | Generic Agno operations (list agents, teams, sessions, delete sessions) | Agno built-in routes (`/teams`, `/agents`, `/sessions/*`) |
| `src/api/routes.ts` | URL builder for all endpoints | Both |

---

## Data Flow Diagram

```
                     Frontend
                        │
         ┌──────────────┼──────────────┐
         │              │              │
    notebooks.ts     os.ts    useAIStreamHandler.tsx
         │              │              │
         │              │         ┌────┴────┐
         │              │    notebook?  team/agent?
         │              │         │         │
         ▼              ▼         ▼         ▼
  ┌─────────────┐ ┌──────────┐ ┌────────────────┐
  │ /api/       │ │ /teams   │ │ /teams/{id}/   │
  │ notebooks/* │ │ /agents  │ │ runs           │
  │ (CRUD)      │ │ /sessions│ │ (raw Agno)     │
  └──────┬──────┘ └──────────┘ └───────┬────────┘
         │                             │
         │     ┌───────────────────┐   │
         └────▶│ /api/notebooks/   │   │
               │ {id}/run          │   │
               │ (WRAPPER)         │   │
               └───────┬───────────┘   │
                       │               │
                       ▼               ▼
              ┌─────────────────────────────┐
              │   Agno Team Execution        │
              │   team_response_streamer()   │
              │   team.arun()                │
              └──────────┬──────────────────┘
                         │
                         ▼
              ┌─────────────────────────┐
              │    agno_sessions        │
              │    (runs JSONB array)   │
              └─────────────────────────┘
```

---

## Key Insight

The notebook wrapper is a **thin orchestration layer**. It does not re-implement any AI logic. Its only jobs are:

1. **Inject notebook context** into the user message so the team knows which notebook it is operating in
2. **Link sessions to notebooks** so the UI can show "these chat sessions belong to this notebook"
3. **Forward everything else to Agno** unchanged — same team, same streamer, same session storage

If you removed the notebook layer, the team would still work via `/teams/notebooklm/runs`, but it would have no awareness of notebooks and no way to scope sessions to a specific notebook.
